// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8 (swiftlang-5.8.0.124.2 clang-1403.0.22.11.100)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DBSCheckoutCore
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CommonCrypto
import Foundation
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
@_hasMissingDesignatedInitializers final public class DBSCheckoutCoreSdk {
  final public var configuration: DBSCheckoutCore.DBSCheckoutCoreSdkConfiguration!
  final public var order: DBSCheckoutCore.Order? {
    get
  }
  public static var buildMode: Swift.String {
    get
  }
  final public func initPayment() -> Combine.AnyPublisher<DBSCheckoutCore.PaymentInitResponse, any Swift.Error>
  final public func getCardInfo(for pan: Swift.String) -> Combine.AnyPublisher<DBSCheckoutCore.CardInfo, any Swift.Error>
  final public func beginPayment(with instrument: DBSCheckoutCore.PaymentInstrument) -> Combine.AnyPublisher<DBSCheckoutCore.PaymentBeginResult, any Swift.Error>
  final public func obtainPaymentStatus() -> Combine.AnyPublisher<DBSCheckoutCore.PaymentStatusResult, any Swift.Error>
  final public func handleClosedForm() -> Combine.AnyPublisher<Swift.Void, any Swift.Error>
  @objc deinit
}
public enum PaymentBeginResult {
  case success
  case tds(webViewRequest: Foundation.URLRequest, tdsFinalRedirectUrl: Foundation.URL)
}
public enum Currency : Swift.Int, Swift.Decodable {
  case unknown
  case rub
  case uz
  case usd
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Swift.Result : Swift.Decodable where Success : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public struct CardInfo {
  public let bankName: Swift.String?
  public var cardType: DBSCheckoutCore.CardType {
    get
  }
  public var isCVCRequired: Swift.Bool {
    get
  }
}
extension DBSCheckoutCore.CardInfo : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
  public static var unknown: DBSCheckoutCore.CardInfo {
    get
  }
}
public enum DBSCheckoutCoreSdkLanguage : Swift.String {
  case ru
  case en
  case uz
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DBSCheckoutCoreSdkEnvironment {
  case merch
  case debug
  case prod
  public static func == (a: DBSCheckoutCore.DBSCheckoutCoreSdkEnvironment, b: DBSCheckoutCore.DBSCheckoutCoreSdkEnvironment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DBSCheckoutCoreSdkColorScheme {
  case light
  case dark
  case systemDefined
  public static func == (a: DBSCheckoutCore.DBSCheckoutCoreSdkColorScheme, b: DBSCheckoutCore.DBSCheckoutCoreSdkColorScheme) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct DBSCheckoutCoreSdkConfiguration {
  public let orderId: Swift.String
  public let environment: DBSCheckoutCore.DBSCheckoutCoreSdkEnvironment
  public let language: DBSCheckoutCore.DBSCheckoutCoreSdkLanguage
  public let colorScheme: DBSCheckoutCore.DBSCheckoutCoreSdkColorScheme
  public init(orderId: Swift.String, environment: DBSCheckoutCore.DBSCheckoutCoreSdkEnvironment, language: DBSCheckoutCore.DBSCheckoutCoreSdkLanguage = .ru, colorScheme: DBSCheckoutCore.DBSCheckoutCoreSdkColorScheme = .systemDefined)
}
public struct Order {
  public var currency: DBSCheckoutCore.Currency {
    get
  }
  public let amount: Swift.Int
  public var amountInCurrency: Swift.Float {
    get
  }
  public let merchantName: Swift.String?
  public let orderNumber: Swift.String?
  public let paymentDetails: Swift.String?
}
extension DBSCheckoutCore.Order : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public struct CardBinding : Swift.Identifiable {
  public let id: Swift.String
  public var expiryDate: Foundation.Date {
    get
  }
  public let maskedPan: Swift.String
  public var cardType: DBSCheckoutCore.CardType {
    get
  }
  public var isCVCRequired: Swift.Bool {
    get
  }
  public typealias ID = Swift.String
}
extension DBSCheckoutCore.CardBinding : Swift.Hashable {
  public static func == (lhs: DBSCheckoutCore.CardBinding, rhs: DBSCheckoutCore.CardBinding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DBSCheckoutCore.CardBinding : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension DBSCheckoutCore.DBSCheckoutCoreSdk {
  convenience public init(configuration: DBSCheckoutCore.DBSCheckoutCoreSdkConfiguration)
}
public enum SDKError : Swift.Int, Swift.Error {
  case unknownError
  case accessTokenObtainError
  case unknownPayment
  case unknownCardBinding
  case newCardInfoError
  case notEnoughMoney
  case securityError
  case newCardRestricted
  case bankDeniedPayment
  case operationsLimitReached
  case paymentAmountExceededLimits
  case cardTypeNotSupported
  case newCardPanError
  case invalidPaymentStatus
  case jwtExpired
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct PaymentInitResponse {
  public let order: DBSCheckoutCore.Order
  public var bindings: [DBSCheckoutCore.CardBinding] {
    get
  }
}
extension DBSCheckoutCore.PaymentInitResponse : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public enum PaymentInstrument {
  case newCard(pan: Swift.String, expiryDate: Foundation.Date, cvc: Swift.String?, needBindCard: Swift.Bool)
  case cardBinding(bindingId: Swift.String, cvc: Swift.String?)
}
extension SwiftUI.Color {
  public init(hex: Swift.Int, decodingOpacity: Swift.Bool = false)
  public init?(string: Swift.String)
}
extension UIKit.UIColor {
  convenience public init(hex: Swift.Int, decodingOpacity: Swift.Bool = false)
  convenience public init?(string: Swift.String)
}
public enum CardType : Swift.String, Swift.Decodable {
  case unknown
  case mastercard
  case visa
  case uzcard
  case humo
  case mir
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Foundation.NumberFormatter {
  public static let changeFormatter: Foundation.NumberFormatter
  public static let currencyFormatter: Foundation.NumberFormatter
}
public protocol CustomNumberFormatterProtocol {
}
extension DBSCheckoutCore.CustomNumberFormatterProtocol {
  public var changeString: Swift.String? {
    get
  }
  public func currencyString(currency: Swift.String) -> Swift.String?
}
extension Swift.Int : DBSCheckoutCore.CustomNumberFormatterProtocol {
}
extension Swift.Double : DBSCheckoutCore.CustomNumberFormatterProtocol {
}
extension Swift.Float : DBSCheckoutCore.CustomNumberFormatterProtocol {
}
public enum PaymentStatusResult {
  case success
  case failure(DBSCheckoutCore.SDKError)
}
extension Foundation.Date {
  public static func fromString(_ string: Swift.String, withFormat format: Swift.String) -> Foundation.Date?
}
extension Combine.Publisher {
  public func sinkIgnoringCompletion(receiveFailure: @escaping ((Self.Failure) -> Swift.Void), receiveValue: @escaping ((Self.Output) -> Swift.Void)) -> Combine.AnyCancellable
  public func sinkResult(_ receiveResult: @escaping ((Swift.Result<Self.Output, Self.Failure>) -> Swift.Void)) -> Combine.AnyCancellable
  public func retry<T>(_ retries: Swift.Int, delay: T.SchedulerTimeType.Stride, scheduler: T = RunLoop.current) -> Combine.AnyPublisher<Self.Output, Self.Failure> where T : Combine.Scheduler
  public func sinkIgnoringAll() -> Combine.AnyCancellable
  public func sinkStore(in set: inout Swift.Set<Combine.AnyCancellable>)
}
extension DBSCheckoutCore.Currency : Swift.Equatable {}
extension DBSCheckoutCore.Currency : Swift.Hashable {}
extension DBSCheckoutCore.Currency : Swift.RawRepresentable {}
extension DBSCheckoutCore.DBSCheckoutCoreSdkLanguage : Swift.Equatable {}
extension DBSCheckoutCore.DBSCheckoutCoreSdkLanguage : Swift.Hashable {}
extension DBSCheckoutCore.DBSCheckoutCoreSdkLanguage : Swift.RawRepresentable {}
extension DBSCheckoutCore.DBSCheckoutCoreSdkEnvironment : Swift.Equatable {}
extension DBSCheckoutCore.DBSCheckoutCoreSdkEnvironment : Swift.Hashable {}
extension DBSCheckoutCore.DBSCheckoutCoreSdkColorScheme : Swift.Equatable {}
extension DBSCheckoutCore.DBSCheckoutCoreSdkColorScheme : Swift.Hashable {}
extension DBSCheckoutCore.SDKError : Swift.Equatable {}
extension DBSCheckoutCore.SDKError : Swift.Hashable {}
extension DBSCheckoutCore.SDKError : Swift.RawRepresentable {}
extension DBSCheckoutCore.CardType : Swift.Equatable {}
extension DBSCheckoutCore.CardType : Swift.Hashable {}
extension DBSCheckoutCore.CardType : Swift.RawRepresentable {}
